using System.Text;
using System.Text.Json;

namespace Rh.MessageFormat.CldrGenerator.Generators;

/// <summary>
/// Generates C# list pattern data classes from CLDR data.
/// </summary>
public class ListPatternCodeGenerator
{
    private readonly CldrConfig _config;

    public ListPatternCodeGenerator(CldrConfig config)
    {
        _config = config;
    }

    /// <summary>
    /// Generates list pattern data classes for all locales.
    /// </summary>
    public async Task GenerateAsync(string cldrRootDir, string outputDir, CancellationToken ct = default)
    {
        Console.WriteLine("Generating list pattern data classes...");

        // Ensure output directory exists
        Directory.CreateDirectory(outputDir);

        // Clean existing generated files
        foreach (var file in Directory.GetFiles(outputDir, "*.g.cs"))
        {
            File.Delete(file);
        }

        var mainPath = Path.Combine(cldrRootDir, _config.Paths.ListPatternsFolder);
        if (!Directory.Exists(mainPath))
        {
            Console.WriteLine($"  Warning: List patterns folder not found at {mainPath}");
            return;
        }

        var generatedLocales = new List<(string Locale, string ClassName)>();

        foreach (var localeDir in GetSupportedLocaleDirectories(mainPath))
        {
            ct.ThrowIfCancellationRequested();

            var localeName = Path.GetFileName(localeDir);
            var normalizedLocale = LocaleFilter.Normalize(localeName);

            if (!LocaleFilter.IsSupported(normalizedLocale))
                continue;

            try
            {
                var data = await CollectListPatternDataAsync(localeDir, ct);
                if (data == null || data.Count == 0)
                    continue;

                var className = GetClassName(normalizedLocale);
                var code = GenerateListPatternClass(normalizedLocale, className, data);

                var filePath = Path.Combine(outputDir, $"{className}.g.cs");
                await File.WriteAllTextAsync(filePath, code, ct);

                generatedLocales.Add((normalizedLocale, className));
            }
            catch (Exception ex)
            {
                Console.WriteLine($"  Warning: Failed to generate list pattern class for '{normalizedLocale}': {ex.Message}");
            }
        }

        Console.WriteLine($"  Generated {generatedLocales.Count} list pattern classes.");

        // Generate the provider class
        await GenerateProviderAsync(outputDir, generatedLocales, ct);
    }

    private IEnumerable<string> GetSupportedLocaleDirectories(string basePath)
    {
        if (!Directory.Exists(basePath))
            return Enumerable.Empty<string>();

        return Directory.GetDirectories(basePath)
            .Where(d =>
            {
                var name = Path.GetFileName(d);
                var normalized = LocaleFilter.Normalize(name);
                return LocaleFilter.IsSupported(normalized);
            })
            .OrderBy(d => d);
    }

    private async Task<Dictionary<string, LocaleListPatternData>?> CollectListPatternDataAsync(string localeDir, CancellationToken ct)
    {
        var listPatternsPath = Path.Combine(localeDir, _config.Paths.ListPatternsFile);
        if (!File.Exists(listPatternsPath))
            return null;

        var json = await File.ReadAllTextAsync(listPatternsPath, ct);
        using var doc = JsonDocument.Parse(json);
        var root = doc.RootElement;

        if (!root.TryGetProperty("main", out var main))
            return null;

        var result = new Dictionary<string, LocaleListPatternData>();

        foreach (var localeProperty in main.EnumerateObject())
        {
            if (localeProperty.Value.TryGetProperty("listPatterns", out var listPatternsObj))
            {
                foreach (var patternType in listPatternsObj.EnumerateObject())
                {
                    var shortName = patternType.Name.Replace("listPattern-type-", "");
                    var typeElement = patternType.Value;

                    result[shortName] = new LocaleListPatternData
                    {
                        Type = shortName,
                        Start = GetStringProperty(typeElement, "start"),
                        Middle = GetStringProperty(typeElement, "middle"),
                        End = GetStringProperty(typeElement, "end"),
                        Two = GetStringProperty(typeElement, "2")
                    };
                }
            }
        }

        return result;
    }

    private static string? GetStringProperty(JsonElement element, string propertyName)
    {
        return element.TryGetProperty(propertyName, out var prop) ? prop.GetString() : null;
    }

    private string GenerateListPatternClass(string locale, string className, Dictionary<string, LocaleListPatternData> data)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// Generated from CLDR data. Do not modify manually.");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using Rh.MessageFormat.Abstractions.Models;");
        sb.AppendLine();
        sb.AppendLine("namespace Rh.MessageFormat.CldrData.Lists.Generated;");
        sb.AppendLine();
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// List pattern data for locale '{locale}'.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal static class {className}");
        sb.AppendLine("{");
        sb.AppendLine($"    public static readonly string Locale = \"{locale}\";");
        sb.AppendLine();
        sb.AppendLine("    private static Dictionary<string, ListPatternData>? _data;");
        sb.AppendLine();
        sb.AppendLine("    public static Dictionary<string, ListPatternData> Data => _data ??= CreateData();");
        sb.AppendLine();
        sb.AppendLine("    private static Dictionary<string, ListPatternData> CreateData()");
        sb.AppendLine("    {");
        sb.AppendLine("        return new Dictionary<string, ListPatternData>(StringComparer.Ordinal)");
        sb.AppendLine("        {");

        foreach (var (type, lpData) in data.OrderBy(kvp => kvp.Key))
        {
            sb.AppendLine($"            {{ \"{type}\", new ListPatternData(");
            sb.AppendLine($"                \"{EscapeString(lpData.Type)}\",");
            sb.AppendLine($"                \"{EscapeString(lpData.Start ?? "{0}, {1}")}\",");
            sb.AppendLine($"                \"{EscapeString(lpData.Middle ?? "{0}, {1}")}\",");
            sb.AppendLine($"                \"{EscapeString(lpData.End ?? "{0}, {1}")}\",");
            sb.AppendLine($"                \"{EscapeString(lpData.Two ?? "{0}, {1}")}\"");
            sb.AppendLine("            ) },");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private async Task GenerateProviderAsync(string outputDir, List<(string Locale, string ClassName)> locales, CancellationToken ct)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// Generated from CLDR data. Do not modify manually.");
        sb.AppendLine($"// Generated: {DateTime.UtcNow:O}");
        sb.AppendLine($"// Locale count: {locales.Count}");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using Rh.MessageFormat.Abstractions.Models;");
        sb.AppendLine("using Rh.MessageFormat.CldrData.Services;");
        sb.AppendLine("using Rh.MessageFormat.CldrData.Lists.Generated;");
        sb.AppendLine();
        sb.AppendLine("namespace Rh.MessageFormat.CldrData.Lists;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Provides list pattern data lookup and auto-registers with CldrDataProvider.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class ListPatternDataProvider");
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly Dictionary<string, Func<Dictionary<string, ListPatternData>>> _locales =");
        sb.AppendLine("        new(StringComparer.OrdinalIgnoreCase)");
        sb.AppendLine("    {");

        foreach (var (locale, className) in locales.OrderBy(l => l.Locale))
        {
            sb.AppendLine($"        {{ \"{locale}\", () => {className}.Data }},");
        }

        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Module initializer that auto-registers this provider with CldrDataProvider.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    [ModuleInitializer]");
        sb.AppendLine("    public static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        CldrDataProvider.ListDataProvider = GetListPatternData;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets list pattern data for a locale and type.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static ListPatternData? GetListPatternData(string locale, string type)");
        sb.AppendLine("    {");
        sb.AppendLine("        var data = GetLocaleData(locale);");
        sb.AppendLine("        if (data == null)");
        sb.AppendLine("            return null;");
        sb.AppendLine();
        sb.AppendLine("        if (data.TryGetValue(type, out var result))");
        sb.AppendLine("            return result;");
        sb.AppendLine();
        sb.AppendLine("        // Fallback to standard type");
        sb.AppendLine("        if (type != \"standard\" && data.TryGetValue(\"standard\", out result))");
        sb.AppendLine("            return result;");
        sb.AppendLine();
        sb.AppendLine("        return null;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static Dictionary<string, ListPatternData>? GetLocaleData(string locale)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_locales.TryGetValue(locale, out var factory))");
        sb.AppendLine("            return factory();");
        sb.AppendLine();
        sb.AppendLine("        // Try base language fallback");
        sb.AppendLine("        var dashIndex = locale.IndexOf('-');");
        sb.AppendLine("        if (dashIndex > 0)");
        sb.AppendLine("        {");
        sb.AppendLine("            var baseLocale = locale.Substring(0, dashIndex);");
        sb.AppendLine("            if (_locales.TryGetValue(baseLocale, out factory))");
        sb.AppendLine("                return factory();");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return null;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets all available list pattern locales.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static IReadOnlyCollection<string> AvailableLocales => _locales.Keys;");
        sb.AppendLine("}");

        var filePath = Path.Combine(outputDir, "ListPatternDataProvider.g.cs");
        await File.WriteAllTextAsync(filePath, sb.ToString(), ct);

        Console.WriteLine($"  Generated list pattern provider with {locales.Count} locales.");
    }

    public static string GetClassName(string locale)
    {
        var safe = locale.Replace('-', '_').Replace('.', '_');
        return $"ListPatternData_{safe}";
    }

    private static string EscapeString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }
}
